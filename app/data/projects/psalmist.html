<div class="page--project page--project--psalmist">

	<div class="slice slice--project-intro">
		<div class="cc">
			<div class="slice_image">
				<img src="/images/projects/psalmist/image-main.png" alt="">
			</div>
			<div class="slice_text">
				<p class="preheading">Free Time Project</p>
				<h2>Psalmist</h2>
				<p class="slice_snippet">
					Psalmist is a simple web app I created to learn Ember.js (and see how it’s different from Angular).<br/>
					<br/>
					It is currently a work-in-progress worship presentation software. It’s built as a front-end client, communicating to a back-end Sails.js RESTful API server to store service lists, songs, backgrounds, etc.<br/>
				</p>
				<a class="slice_link" href="https://github.com/michaeljonathan/psalmist" target="_blank"><i class="fa fa-github"></i> View on GitHub</a>
			</div>
		</div>
	</div>

	<div class="slice slice--project">
		<div class="cc">
			<img src="/images/projects/psalmist/ember-or-angular.png" alt="" style="width: 250px; max-width: 50%;">
			<h2>To Ember or to Angular?</h2>
			<p>
				As web applications are expected to become more complex and handle more user interactivity, jQuery will not suffice and a more powerful framework is needed. I've been playing around with a popular solution, <a href="https://angularjs.org/" target="_blank">Angular.js</a>, a little bit; I went through its tutorial and then used when developing certain features at work. Yet, Angular is hardly the only option out there; one popular alternative include <a href="http://emberjs.com/" target="_blank">Ember.js</a>.<br>
				<br>
				I wanted to know how Ember presents a different front-end development experience than Angular. This website, <em>mjonathan.com</em>, is built with Angular.js. Although this site is not exactly an interactive web application; I used Angular anyway, combined with <a href="https://github.com/angular-ui/ui-router" target="_blank">ui-router</a>, for a to provide a faster and more fluid browsing experience, avoiding then need to keep reloading the site when clicking on links.<br>
				<br>
				<span class="text--large">Angular can be used to create complex, highly interactive web applications, in so many ways.</span><br>
				<br>
				A web app can be wired with Angular in countless ways. Angular lets us supercharge HTML by writing directives with limitless possible uses. We can (and actually need to) pick and choose their own build tools. Angular has no built-in object store - developers are generally expected to write their own services/factories that handle the front-end temporary objects. Angular’s built-in routing is also very limited, hence the need to install third-party plugins such as ui-routing used by this site. Angular lets us integrate it with anything, add many kinds of plugins into it, and create apps in any way as preferred.<br>
				<br>
				<em>But perhaps, this much degree of flexibility isn’t for every app.</em><br>
				<br>
				<span class="text--large">Ember.js comes as a complete framework, highly embracing convention over configuration.</span><br>
				<br>
				A web app can be wired with Ember in the particular way that the framework expects. It’s designed for fastest development when built while closely following its guides and utilizing its built-in toolset. Immediately noticeable things that are absent in Angular but provided by Ember include powerful routing, a front-end data store and object model, template binding without dirty-checking, even <a href="http://www.ember-cli.com/" target="_blank">an entire CLI</a> with select build tools. There’s also a strong convention over how the project directory should be structured, and how every file must be named.<br>
				<br>
				Since I’m starting a casual project from scratch, I wanted to give it a shot.
			</p>
		</div>
	</div>

	<div class="slice slice--project">
		<div class="cc">
			<h2>The App So Far</h2>
			<p class="p--center">Casually working on the app on some of my free time, here's what's been developed so far:</p>
			<p class="p--center"><span class="text--large">Service Page (Controls Live Display)</span></p>
			<img src="/images/projects/psalmist/scrshot-page-service-01.jpg" alt="" class="screenshot screenshot--snb">
			<p class="p--center"><span class="text--large">Library Pages (Manages Songs)</span></p>
			<img src="/images/projects/psalmist/scrshot-page-library-songs-01.jpg" alt="" class="screenshot screenshot--snb">
			<img src="/images/projects/psalmist/scrshot-page-library-song-editor-01.jpg" alt="" class="screenshot screenshot--snb">
		</div>
	</div>

	<div class="slice slice--project">
		<div class="cc">
			<h2>The Stack</h2>
			<img src="/images/projects/psalmist/stack-01.png" alt="" class="diagram--wide img--for-desktop">
			<img src="/images/projects/psalmist/stack-01-mobile.png" alt="" class="diagram--wide img--for-mobile">
			<p>
				<strong>Ember is clearly engineered to build a nice 'chain' of separated concerns.</strong> The user interacts with the Handlebars-rendered template comprised of one <em>component</em> inside another. As the user takes actions, it fires events that is either handled by each component's own JS or explicitly bubbled up to its parent component. A component will then eventually update the UI, which automatically updates the HTML DOM. If an action requests data or sends data to the server, the component will use <a href="https://github.com/emberjs/data" target="_blank">Ember-Data</a>'s API to find, create or update models as necessary. This will not only update the DOM, but also the front-end temporary database and send up RESTful requests to the server. Ember adapters can be used to define which server handles the APIs for each model, and Ember serializers can transform the payload to and from the API server's format.
			</p>
			<h4>Back-end</h4>
			<p>
				Usually spending a lot of my time at work with Apache, PHP and MySQL, I wanted to try something new. So for the back-end I chose to try out <a href="http://sailsjs.org/" target="_blank">Sails.js</a> (a back-end <a href="https://nodejs.org/" target="_blank">Node.js</a> framework built on top of <a href="http://expressjs.com/" target="_blank">Express.js</a>) to serve the RESTful API and <a href="https://www.mongodb.org/" target="_blank">MongoDB</a> to store all the data. It's interesting how my entire stack now uses JavaScript, as I never need to context-switch between languages, and in the future I can use the same libraries on the front-end as well as on the back-end if ever needed. It's also nice that Sails has a flexible ORM system that works not only with MongoDB, but also with MySQL and several other kinds of databases, which can be configured per-model.<br>
				<br>
				I call the back-end API server <a href="https://github.com/michaeljonathan/bookofpsalms" target="_blank">Book of Psalms</a>. <strong>Complex linking between models are done server-side, to ensure a consistent database no matter what requests are made by the front-end side.</strong> For example, if a PUT request on one object model A should affect another object model B that contains it, this link between two objects will only require one PUT request for object model A, and not object model B. The front-end app may implement similar logic to make sure updates to object model A also updates object model B, or in my case, I simply called .reload() on object model B using Ember, which creates a GET request. All these updates are written onto a MongoDB database.
			</p>
		</div>
	</div>

	<div class="slice slice--project">
		<div class="cc">
			<h2>What I learned</h2>
			<p>
				I found Ember to be an interesting front-end Framework, bringing its own paradigm of how a front-end web app should be wired up. This comes with things that I love and others that I don't.
			<p>
			<h3>The Awesome</h3>
			<p>
				<span class="text--large">Hits the ground running</span><br>
				Ember lets me start developing quickly once <a href="https://www.npmjs.com/" target="_blank">NPM</a> is installed. It comes with essential features and a complete CLI. I didn’t need lots of pre-wiring to start developing. I didn’t even need to import a routing plug-in.<br>
				<br>
				<span class="text--large">Neater code</span><br>
				Ember encourages a cleaner codebase by design. The way the app is designed as a hierarchy of components discourages developers from putting too many things in a given file. Every time I inserted a component into an Ember template, I needed to explicitly pass in everything it depends on from its parent context. This brings contrast into the separated concerns of each component, and helps prevent confusing event firings as every component must explicitly bubble up actions to its parents.<br>
				<br>
				<span class="text--large">Ember-Data Front-end ORM</span><br>
				Ember-data’s front-end "ORM" object model is great. I find having access to computed properties great (something difficult to replicate in Angular). It's also nice to be able to call object.save() and see it immediately updating its bound elements in the HTML DOM and fire a PUT request, all done automatically without having to deal with the Angular quirks of explicitly calling <span class="text--code">$scope.$apply(...)</span>, witnessing the app run its dirty checks, as well as calling specific services/factories to make sure it’s also updated on the server-side. Naturally, components' controllers will never know of the API used to communicate to the back-end server - on the other hand Angular apps must be thoughtfully built to prevent this from happening.<br>
				<br>
				<span class="text--large">BYO Back-end</span><br>
				Ember is purely front-end. While it demands strict conventions with the way the it's built, we're still free to hook it up with any back-end system we want. Some frameworks went further than this as to tie the front-end and back-end system completely by default, such as <a href="https://www.meteor.com/" target="_blank">Meteor.js</a> (which is also interesting, but with a full end-to-end framework comes significant commitment).
			</p>
			<h3>The Not So Awesome</h3>
			<p>
				<span class="text--large">Invisible Wires</span><br>
				Ember seems eager to redefine completely how a web app should we wired, which made it harder for me to see how everything is actually wired up and how things are working. I find it less intuitive than Angular to get used to (to this point I still find it easier to read Angular code than Ember code, and I consider Angular directives to be syntactically nicer than Handlebars).<br>
				<br>
				<span class="text--large">Total Framework Commitment</span><br>
				It can be challenging to do anything that does not conform to its conventions. Ember can’t be simply be plugged into existing web apps as an additional library (like Angular can). While possible, it might not be the tricky to completely integrate Ember into an existing build system, as Ember has its own ideals on where every file should be present. At work, I’ve used Ionic, an entire HTML mobile app framework built on top of Angular and Cordova. I’d say that, had Ionic used Ember instead, things would probably be more complicated for the Ionic/ngCordova team to work with and for us developers to understand.<br>
				<br>
				<span class="text--large">The Learning Curve</span><br>
				I personally find multiple aspects of the framework JS API rather unintuitive, one of the main ones include the promises-centric design. I find it tricky to tell when I should do <span class="text--code">var object = this.get('objectName');</span> and when I should instead invoke <span class="text--code">this.get('objectName').then(function(object){...});</span>.<br>
				<br>
				<span class="text--large">Build successful - 15872ms</span><br>
				Ember-CLI could perform better. I find build times inconsistent, ranging from 4 seconds to almost a minute sometimes, but usually around 15 seconds at this point, which I don’t find impressive for a simple application such as Psalmist - and this was after optimizing the Windows environment for Ember CLI (which brought down the 'vanilla' Ember app compile time down from almost 30 seconds to around 5 seconds).<br>
			</p>
		</div>
	</div>

</div>
